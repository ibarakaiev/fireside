defmodule Fireside.Util.Install do
  def install(component) do
    Mix.shell().info("Installing #{component}")

    {_component_name, [path: component_path]} = determine_dep_type_and_version(component)

    if not File.dir?(component_path) do
      raise "directory `#{component_path} doesn't exist"
    end

    fireside_config_path = Path.join(component_path, "/.fireside.exs")

    if not File.exists?(fireside_config_path) do
      raise "#{component_path} is not a Fireside component"
    end

    fireside_opts = eval_file_with_keyword_list(fireside_config_path)

    Keyword.validate!(fireside_opts, [:lib, :overwritable, :tests])

    igniter =
      for kind <- [:lib, :tests], reduce: Igniter.new() do
        igniter ->
          {includes, _opts} = Keyword.pop!(fireside_opts, kind)

          for glob <- includes, reduce: igniter do
            igniter ->
              file_paths =
                Path.join(component_path, glob)
                |> GlobEx.compile!()
                |> GlobEx.ls()

              for file_path <- file_paths, reduce: igniter do
                igniter ->
                  import_component_file_to_project(igniter, file_path, kind)
              end
          end
      end

    Igniter.do_or_dry_run(igniter, [])
  end

  defp import_component_file_to_project(igniter, file_path, kind) do
    final_ast =
      file_path
      |> File.read!()
      |> Sourceror.parse_string!()
      |> replace_module_prefix_to_mix_project_name()
      |> compute_and_include_hash()

    module_name = get_module_name(final_ast)

    proper_location =
      case kind do
        :lib ->
          Igniter.Code.Module.proper_location(module_name)

        :tests ->
          Igniter.Code.Module.proper_test_location(module_name)
      end

    Igniter.create_new_elixir_file(
      igniter,
      proper_location,
      Sourceror.to_string(final_ast)
    )
  end

  defp replace_module_prefix_to_mix_project_name(ast) do
    app_name_atom = Mix.Project.get!() |> Module.split() |> List.first() |> String.to_atom()

    {:defmodule, _defmodule_meta, [{:__aliases__, _aliases_meta, [prefix | _suffix]} | _rest]} =
      ast

    ast
    |> Macro.prewalk(fn
      {:__aliases__, aliases_meta, [^prefix | rest]} ->
        {:__aliases__, aliases_meta, [app_name_atom | rest]}

      node ->
        node
    end)
  end

  defp compute_and_include_hash(ast) do
    hash = :crypto.hash(:sha, Sourceror.to_string(ast)) |> Base.encode16()

    Sourceror.prepend_comments(
      ast,
      [
        %{
          line: 1,
          previous_eol_count: 1,
          next_eol_count: 1,
          text: "#! fireside:#{hash}"
        },
        %{
          line: 1,
          previous_eol_count: 1,
          next_eol_count: 1,
          text: "#! DO NOT EDIT this file. Run mix fireside.unlock to stop syncing."
        }
      ],
      :leading
    )
  end

  defp get_module_name(quoted) do
    {:defmodule, _defmodule_meta, [{:__aliases__, _aliases_meta, module_name} | _rest]} =
      quoted

    Module.concat(module_name)
  end

  defp determine_dep_type_and_version(requirement) do
    case String.split(requirement, "@", trim: true) do
      [_package] ->
        raise "only @path components are currently supported"

      [package, version] ->
        case version do
          "git:" <> _requirement ->
            raise "@git components are not yet supported"

          "github:" <> _requirement ->
            raise "@github components are not yet supported"

          "path:" <> requirement ->
            [path: requirement]

          _version ->
            raise "only @path components are currently supported"
        end
        |> case do
          :error ->
            :error

          requirement ->
            {package, requirement}
        end
    end
  end

  # borrowed from mix format
  defp eval_file_with_keyword_list(path) do
    {opts, _} = Code.eval_file(path)

    unless Keyword.keyword?(opts) do
      Mix.raise("Expected #{inspect(path)} to return a keyword list, got: #{inspect(opts)}")
    end

    opts
  end
end
